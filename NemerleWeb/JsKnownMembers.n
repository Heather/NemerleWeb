using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using NemerleWeb.Utils;

using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;

namespace NemerleWeb
{
  internal module TypeHelper
  {
    [Memoize]
    private InternalTypeName(type : TypeInfo) : string
    {
      if (type.SystemType != null) type.SystemType.FullName else type.FrameworkTypeName;
    }
    
    public TypeName(type : TypeInfo) : string
    {
      if (type != null) InternalTypeName(type) else "";
    }
                  
    public RemoveGetSet(methodName : string) : string
    {
      if (IsGetSet(methodName)) methodName.Substring(4) else methodName
    }
      
    public IsGetSet(methodName : string) : bool
    {
      methodName.StartsWith("get_") || methodName.StartsWith("set_")
    }
      
    public PropertyToField(prop : JsAST, isObservable : bool) : JsAST
    {   
      match(prop)
      {
      | PropertyGet(obj, name, false) => JsAST.FieldRef(obj, name, !isObservable)
      | _ => prop
      }
    }
  }

  internal module JsAstExtensions
  {
    public static MethodCall(this self : JsAST, method : string, parms : list[JsAST]) : JsAST
    {
      JsAST.Call(JsAST.MethodRef(self, method.FirstCharacterToLower()), parms)
    }
    
    public static StaticCall(this type : string, method : string, parms : list[JsAST]) : JsAST
    {
      JsAST.Call(JsAST.StaticRef(type, method.FirstCharacterToLower()), parms)
    }
  }
  
  internal module JsKnownMembersHelper
  {
    public Default(type : TypeInfo, left : JsAST, member : IMember, parms : list[JsAST]) : JsAST
    {
      Message.Warning(
        member.Location,
        $"Invalid $(member.Name) with $(TypeHelper.TypeName(type)) type, params: ..$parms" +
        " not implemented in JS");
      JsAST.Call(JsAST.MethodRef(left, TypeHelper.RemoveGetSet(member.Name)), parms)
    }
    
    public DefaultThrow(type : TypeInfo, _left : JsAST, member : IMember, parms : list[JsAST]) : JsAST
    {
      throw ArgumentException(
        $"Invalid $(member.Name) with $(TypeHelper.TypeName(type)) type, params: ..$parms" +
        " not implemented in JS. $(member.Location)");
    }
  }
  
  module JsKnownMembers
  {
    public Convert(call : TExpr.Call, builder : TExpr -> JsAST) : JsAST
    {
      match (call)
      {
        | Call(MethodRef(obj = Call(MethodRef(meth = serverMeth, obj = obj), _, _), meth = meth), parms, _)
          when serverMeth.Name == "get_server" && obj is TExpr.This =>
            def parameters =
              if (parms.Length > 0) parms.Zip(meth.GetParameters()).Take(parms.Length - 1).Map((cp, mp) => (mp.name, builder(cp.expr)))
              else [];
            def callback = if(parms.Length > 0) builder(parms.Last().expr) else JsAST.Void();
            match(callback)
            {
              | Seq(DefValue as dv :: cb :: []) => JsAST.Seq([dv, JsAST.ServerCall(meth.Name, serverMeth.DeclaringType.Name, parameters, cb)])
              | _ => JsAST.ServerCall(meth.Name, serverMeth.DeclaringType.Name, parameters, callback)
            }
        | Call(MethodRef(_, meth, _, _), [modelParm, viewParm], _) when meth.Name == "GetTemplateName" =>             
          match(modelParm, viewParm)
          {
          | (Parm(expr = TExpr.Literal(Literal.String(model))), Parm(expr = TExpr.Literal(Literal.String(view)))) =>
            JsAST.Code($"nweb.utils.getTemplateName(this.$model, '$view')")
          | _ => Message.FatalError("Invalid GetTemplateName call, use 'name' macro")
          }
        | Call(MethodRef(obj = o, meth = meth), parms, _) =>
          ConvertMethod(o.Type.TypeInfo, builder(o), meth, parms.Map(p => builder(p.expr)))
        | Call(StaticRef(from = fromType, mem = meth) as left, parms, _) =>
            ConvertMethod(fromType.TypeInfo, builder(left), meth, parms.Map(p => builder(p.expr)))
                
        | Call(OpCode as op, parms, _) => JsAST.Call(builder(op), parms.Map(p => builder(p.expr)))
        | Call(Base, _, _) => JsAST.Void()        
        | Call(s, _, _) => Message.Warning($"Unsupported call to $s"); JsAST.Void()          
      }
    }
      
    [MatchCollector(
      JsKnownMembersBase.ConvertMethod,
      JsKnownMembersBCL.ConvertMethod,
      JsKnownMembersBCLString.ConvertMethod,
      JsKnownMembersNemerle.ConvertMethod,
      JsKnownMembersLinq.ConvertMethod)]
    public ConvertMethod(type : TypeInfo, left : JsAST, member : IMember, parms : list[JsAST]) : JsAST
    {
      match (member.Name, parms)
      {
        | _ when member.Name.StartsWith("get_") =>
          JsAST.PropertyGet(left, TypeHelper.RemoveGetSet(member.Name), false)
        | (_, [h]) when member.Name.StartsWith("set_") =>
          JsAST.PropertySet(left, TypeHelper.RemoveGetSet(member.Name), h)
        | _ => JsKnownMembersHelper.Default(type, left, member, parms)
      }
    }
      
    public ConvertField(obj : TExpr, field : IField, builder : TExpr -> JsAST) : JsAST
    {
      match(field)
      {
      //| _ when field.Name == "hd" && field.DeclaringType.FullName == "Nemerle.Core.Cons[T]" => JsAST.Call(JsAST.Indexer(builder(obj)), [JsAST.Literal(JsLiteral.Integer(0))])
      //| _ when field.Name == "tl" && field.DeclaringType.FullName == "Nemerle.Core.Cons[T]" => JsAST.Call(JsAST.MethodRef(builder(obj), "splice"), [JsAST.Literal(JsLiteral.Integer(1))])        
      | _ => JsAST.FieldRef(builder(obj), field.Name, false) 
      }
    }
  }
}
