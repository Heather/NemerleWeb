using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using NemerleWeb.Utils;

using System;
using System.Collections.Generic;
using System.Linq;

namespace NemerleWeb
{
  internal module TypeHelper
  {
    [Memoize]
    private InternalTypeName(type : TypeInfo) : string
    {
      if (type.SystemType != null) type.SystemType.FullName else type.FrameworkTypeName;
    }
    
    public TypeName(type : TypeInfo) : string
    {
      if (type != null) InternalTypeName(type) else "";
    }
                  
    public RemoveGetSet(methodName : string) : string
    {
      if (IsGetSet(methodName)) methodName.Substring(4) else methodName
    }
      
    public IsGetSet(methodName : string) : bool
    {
      methodName.StartsWith("get_") || methodName.StartsWith("set_")
    }
      
    public PropertyToField(prop : JsAST, isObservable : bool) : JsAST
    {   
      match(prop)
      {
      | PropertyGet(obj, name) => JsAST.FieldRef(obj, name, !isObservable)
      | _ => prop
      }
    }
  }
  
  internal module JsKnownMembersHelper
  {
    public Default(type : TypeInfo, left : JsAST, member : IMember, parms : list[JsAST]) : JsAST
    {
      Message.Warning(
        member.Location,
        $"Invalid $(member.Name) with $(TypeHelper.TypeName(type)) type, params: ..$parms" +
        " not implemented in JS");
      JsAST.Call(JsAST.MethodRef(left, TypeHelper.RemoveGetSet(member.Name)), parms)
    }
    
    public DefaultThrow(type : TypeInfo, _left : JsAST, member : IMember, parms : list[JsAST]) : JsAST
    {
      throw ArgumentException(
        $"Invalid $(member.Name) with $(TypeHelper.TypeName(type)) type, params: ..$parms" +
        " not implemented in JS. $(member.Location)");
    }
  }
  
  module JsKnownMembers
  {
      public Convert(call : TExpr.Call, builder : TExpr -> JsAST) : JsAST
      {    
        match (call)
        {
          | Call(MethodRef(obj = Call(MethodRef(meth = serverMeth, obj = obj), _, _), meth = meth), parms, _)
            when serverMeth.Name == "get_server" && obj is TExpr.This =>
              def parameters =
                if (parms.Length > 0) parms.Zip(meth.GetParameters()).Take(parms.Length - 1).Map((cp, mp) => (mp.name, builder(cp.expr)))
                else [];
              def callback = if(parms.Length > 0) builder(parms.Last().expr) else JsAST.Void();
              match(callback)
              {
                | Seq(DefValue as dv :: cb :: []) => JsAST.Seq([dv, JsAST.ServerCall(meth.Name, serverMeth.DeclaringType.Name, parameters, cb)])
                | _ => JsAST.ServerCall(meth.Name, serverMeth.DeclaringType.Name, parameters, callback)
              }
                      
          | Call(MethodRef(obj = o, meth = meth) as m, parms, _) =>
              ConvertMethod(o.Type.TypeInfo, builder(o), meth, parms.Map(p => builder(p.expr)))
          
          | Call(StaticRef(from = fromType, mem = meth) as left, parms, _) =>
              ConvertMethod(fromType.TypeInfo, builder(left), meth, parms.Map(p => builder(p.expr)))
                
          | Call(OpCode as op, parms, _) => JsAST.Call(builder(op), parms.Map(p => builder(p.expr)))
          | Call(Base, _, _) => JsAST.Void()        
          | Call(s, _, _) => Message.Warning($"Unsupported call to $s"); JsAST.Void()          
        }
      }
      
      [MatchCollector(
        JsKnownMembersBase.ConvertMethod,
        JsKnownMembersBCL.ConvertMethod,
        JsKnownMembersNemerle.ConvertMethod,
        JsKnownMembersLinq.ConvertMethod)]
      public ConvertMethod(type : TypeInfo, left : JsAST, member : IMember, parms : list[JsAST]) : JsAST
      {
        match (member.Name, parms)
        {
          | _ => JsKnownMembersHelper.Default(type, left, member, parms)
        }
      }
  }
}
