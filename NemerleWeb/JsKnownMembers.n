using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using NemerleWeb.Utils;

using System;
using System.Collections.Generic;
using System.Linq;

namespace NemerleWeb
{
  internal module TypeHelper
  {
    [Memoize]
    public TypeName(type : TypeInfo) : string
    {
      if (type != null)          
        if (type.SystemType != null) type.SystemType.FullName
        else                         type.FrameworkTypeName;
      else
        "";
    }
                  
    public RemoveGetSet(methodName : string) : string
    {
      if (IsGetSet(methodName)) methodName.Substring(4) else methodName
    }
      
    public IsGetSet(methodName : string) : bool
    {
      methodName.StartsWith("get_") || methodName.StartsWith("set_")
    }
      
    public PropertyToField(prop : JsAST) : JsAST
    {          
      | PropertyGet(obj, name) => JsAST.FieldRef(obj, name)
      | _ => prop
    }
  }
  
  module JsKnownMembers
  {
      public Convert(call : TExpr.Call, builder : TExpr -> JsAST) : JsAST
      {    
        match (call)
        {
          | Call(MethodRef(obj = Call(MethodRef(meth = serverMeth, obj = obj), _, _), meth = meth), parms, _)
            when serverMeth.Name == "get_server" && obj is TExpr.This =>
              def parameters =
                if (parms.Length > 0) parms.Zip(meth.GetParameters()).Take(parms.Length - 1).Map((cp, mp) => (mp.name, builder(cp.expr)))
                else [];
              def callback = if(parms.Length > 0) builder(parms.Last().expr) else JsAST.Void();
              match(callback)
              {
                | Seq(DefValue as dv :: cb :: []) => JsAST.Seq([dv, JsAST.ServerCall(meth.Name, serverMeth.DeclaringType.Name, parameters, cb)])
                | _ => JsAST.ServerCall(meth.Name, serverMeth.DeclaringType.Name, parameters, callback)
              }
                      
          | Call(MethodRef(obj = o, meth = meth) as m, parms, _) =>
              ConvertMethod(o.Type.TypeInfo, builder(o), meth, parms.Map(p => builder(p.expr)))
          
          | Call(StaticRef(from = fromType, mem = meth) as left, parms, _) =>
              ConvertMethod(fromType.TypeInfo, builder(left), meth, parms.Map(p => builder(p.expr)))
                
          | Call(OpCode as op, parms, _) => JsAST.Call(builder(op), parms.Map(p => builder(p.expr)))
          | Call(Base, _, _) => JsAST.Void()        
          | Call(s, _, _) => Message.Warning($"Unsupported call to $s"); JsAST.Void()          
        }
      }
      
      [MatchCollector(
        JsKnownMembersBase.ConvertMethod,
        JsKnownMembersBCL.ConvertMethod,
        JsKnownMembersNemerle.ConvertMethod,
        JsKnownMembersLinq.ConvertMethod)]
      public ConvertMethod(type : TypeInfo, left : JsAST, member : IMember, parms : list[JsAST]) : JsAST
      {
        match (member.Name, parms)
        {
          | ("apply", _) =>
            Message.Warning(<#Must implement "apply" method for test case:
def test(description, res)
{
  Results.Add((description, res()));
}#>);
            JsAST.Call(JsAST.MethodRef(left, TypeHelper.RemoveGetSet(member.Name)), parms);
            
          | _ =>
            _ = type; _ = left; _ = member; _ = parms;
            Message.Warning(
              member.Location,
              $"Invalid $(member.Name) with $(TypeHelper.TypeName(type)) type, params: ..$parms" +
              " not implemented in JS");
            JsAST.Call(JsAST.MethodRef(left, TypeHelper.RemoveGetSet(member.Name)), parms)
        }
      }
  }
}
