using Nemerle;
using Nemerle.Extensions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Peg;

using System;
using System.Collections.Generic;
using System.Linq;

namespace TSParser
{
  type TypeReference = string;
  type ClassOrInterfaceTypeList = List[TypeReference];
  
  public variant DeclarationElement : Located
  {
    | Reference { Value : ReferenceRule; }
    | ExportAssignment { Value : ExportAssignmentRule; }
    | InterfaceDeclaration { Value : InterfaceDeclarationRule; }
    | ExternalImportDeclaration { Value : ExternalImportDeclarationRule; }
    | ImportDeclaration { Value : ImportDeclarationRule; }
    | AmbientDeclaration { Value : AmbientDeclarationRule; }
  }
  
  public variant ReferenceRule
  {
    | NoDefaultLib
    | Lib { Path : string; }
  }
  
  public variant ExportAssignmentRule
  {
    | Module { Name : string; ModuleEntity : string; }
    | Identifier { Name : string; }
  }
  
  [Record]
  public class ExternalImportDeclarationRule
  {
    public Name : string { get; }
    public ModuleReference : string { get; }
  }
  
  [Record]
  public class ImportDeclarationRule
  {
    public Name : string { get; }
    public Entity : string { get; }
  }
  
  [Record]
  public class InterfaceDeclarationRule
  {
    public Name : string { get; }
    public TypeParameters : List[object] { get; }
    public Extends : ClassOrInterfaceTypeList { get; }
    public Type : object { get; }
  }
  
  public variant AmbientDeclarationRule
  {
    | VariableDeclaration
    | FunctionDeclaration
    | ClassDeclaration
    | EnumDeclaration
    | ExternalModuleDeclaration
    | ModuleDeclaration
  }
  
  #region Old AST
  type ClassHeritage = option[string] * list[string];
  
  public enum MemberAccess
  {
    | Public
    | Private
  }
  
  public variant TSClassMemberPart
  {
    [StructuralEquality(Ignore = [Type])]    
    | Variable { Name : string; Type : option[TSType]; }
    
    [StructuralEquality(Ignore = [Optional, ReturnType])]
    | Method 
      {
        Name : string;
        Optional : bool;
        Params : list[TSParam];
        ReturnType : option[TSType];
      }
  }
  
  public variant TSClassMember
  {
    [StructuralEquality]    
    | Constructor { Params : list[TSParam]; }
    
    [StructuralEquality(Ignore = [Static, Access])]
    | Member
      {
        Part : TSClassMemberPart;
        Static : option[bool];
        Access : option[MemberAccess];
      }
  }
  
  public variant TSParam
  {
    [StructuralEquality(Ignore = [Name, Access])]
    | Required
      {
        Name : string;
        Type : option[TSType];
        Access : option[MemberAccess];
      }
     
    [StructuralEquality(Ignore = [Name, Optional, Access])]
    | Option
      { 
        Name : string;
        Optional : bool;
        Type : option[TSType];
        Access : option[MemberAccess];
      }
      
    [StructuralEquality(Ignore = [Name])]
    | Rest { Name : string; Type : TSType.Array; }
  }
  
  // Index parameter type either number or string.
  // Nothing else is allowed.
  [StructuralEquality]
  public variant TSIndexParamType
  {
    | Number
    | String
  }
    
  public variant TSObject
  {
    [StructuralEquality(Ignore = [ReturnType])]
    | Call { Params : list[TSParam]; ReturnType : option[TSType]; }
    
    [StructuralEquality]
    | Construct { Params : list[TSParam]; Type : option[TSType]; }
    
    [StructuralEquality(Ignore = [ParamName, ReturnType])]
    | Index
      { 
        ParamName : string;
        ParamType : TSIndexParamType;
        ReturnType : TSType;
      }
      
    [StructuralEquality(Ignore = [Optional, Type])]
    | Property { Name : string; Optional : bool; Type : option[TSType]; }
    
    [StructuralEquality(Ignore = [Optional, ReturnType])]
    | Function
      {
        Name : string;
        Optional : bool;
        Params : list[TSParam];
        ReturnType : option[TSType];
      }
  }
  
  [Record]
  [StructuralEquality]
  public class TSEnumElement
  {
    Name : string;
    Initialiser : option[string];
  }
  
  [StructuralEquality]
  public variant TSType
  {
    | Any
    | Number
    | Bool
    | String
    | Void
    | Named { Name : string; }
    | Array { Type : TSType; Rank : int; }
    | Object { Members : list[TSObject]; }
    | Lambda { Params : list[TSParam]; ReturnType : TSType; }
    | New { Params : list[TSParam]; ReturnType : TSType; }
  }

  public variant TSAmbient
  {
    | Variable { Name : string; Type : option[TSType]; }
    | Function { Name : string; Signature : object; }
  }
  
  [StructuralEquality]
  public variant TSGlobal
  {
    | Variable { Name : string; Type : option[TSType]; }
    | Construct { Params : list[TSParam]; ReturnType : option[TSType]; }
    | Function
      {
        Name : string;
        Params : list[TSParam];
        ReturnType : option[TSType];
      }
    | Class 
      { 
        Name : string;
        Extends : option[string]; 
        Implements : list[string];
        Members : list[TSClassMember];
      }
    | Interface { Name : string; Extends : list[string]; Type : TSType.Object; }
    | Module { Name : string; Members : list[TSGlobal]; }
    | Enum { Name : string; Elements : list[TSEnumElement]; }
    | Import { Name : string; ModuleReference : string; }
    | Export { Identifier : string; }
    | ReferencePath { path : string; }
    | ReferenceNoDefaultLib
  }
  #endregion
}
