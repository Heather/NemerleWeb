using Nemerle;
using Nemerle.Extensions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Peg;

using System;
using System.Collections.Generic;
using System.Linq;

namespace TSParser
{
  public variant DeclarationElement
  {
    | Reference { Value : ReferenceRule; }
    | ExportAssignment { Value : ExportAssignmentRule; }
    | InterfaceDeclaration { Value : InterfaceDeclarationRule; }
    | ExternalImportDeclaration { Value : ExternalImportDeclarationRule; }
    | ImportDeclaration { Value : ImportDeclarationRule; }
    | AmbientDeclaration { Value : AmbientDeclarationRule; }
  }
  
  public variant ReferenceRule
  {
    | NoDefaultLib
    | Lib { Path : string; }
  }
  
  public variant ExportAssignmentRule
  {
    | Module { Name : string; ModuleEntity : string; }
    | Identifier { Name : string; }
  }
  
  [Record]
  public class ExternalImportDeclarationRule
  {
    public Name : string { get; }
    public ModuleReference : string { get; }
  }
  
  [Record]
  public class ImportDeclarationRule
  {
    public Name : string { get; }
    public Entity : string { get; }
  }
  
  [Record]
  public class InterfaceDeclarationRule
  {
    public Name : string { get; }
    public TypeParameters : List[ScriptTypeParameter] { get; }
    public Extends : List[ScriptType] { get; }
    public Type : ScriptType.Object { get; }
  }
  
  public variant AmbientDeclarationRule
  {
    | VariableDeclaration
      {
        Name : string;
        Type : option[ScriptType];
      }
    | FunctionDeclaration
      {
        Name : string;
        Signature : ScriptCallSignature;
      }
    | ClassDeclaration
      {
        Name : string;
        TypeParameters : List[ScriptTypeParameter];
      }
    | EnumDeclaration
      {
        Name : string;
        Members : List[EnumMember];
      }
    | ExternalModuleDeclaration
      {
        Name : string;
      }
    | ModuleDeclaration
      {
        Name : string;
      }
  }
  
  public variant ScriptType
  {
    | Any
    | Number
    | Boolean
    | String
    | Void
    | Ref { Name : string; TypeArguments : List[ScriptType]; }
    | Query { Name : string; }
    | Array { Type : ScriptType; Rank : int; }
    | Object { Members : List[ScriptObject]; }
    | Function { Parameters : List[ScriptParameter]; ReturnType : ScriptType; }
    | Constructor { Parameters : List[ScriptParameter]; ReturnType : ScriptType; }
  }
  
  public variant ScriptObject
  {
    | Property
      {
        Name : string;
        Optional : bool;
        Type : option[ScriptType];
      }
    | Call { Value : ScriptCallSignature; }
    | Construct
      {
        TypeParameters : List[ScriptTypeParameter];
        Parameters : List[ScriptParameter];
        ReturnType : option[ScriptType];
      }
    | Index
      {
        ParameterName : string;
        ParameterType : IndexParameterType;
        ReturnType : ScriptType;
      }
    | Method
      {
        Name : string;
        Optional : bool;
        Signature : ScriptCallSignature;
      }
  }
  
  public variant IndexParameterType
  {
    | Number
    | String
  }
  
  [Record]
  public class ScriptCallSignature
  {
    public TypeParameters : List[ScriptTypeParameter] { get; }
    public Parameters : List[ScriptParameter] { get; }
    public ReturnType : option[ScriptType] { get; }
  }
  
  [Record]
  public class ScriptTypeParameter
  {
    public Name : string { get; }
    public Constraint : option[ScriptType] { get; }
  }
  
  public variant ScriptParameter
  {
    | Required
      {
        Value : RequiredParameter;
      }
    | Optional
      {
        Name : string;
        Type : option[ScriptType];
        Access : option[MemberAccess];
      }
    | Rest
      {
        Name : string;
        Type : option[ScriptType];
      }
  }
  
  public variant RequiredParameter
  {
    | Literal { Name : string; Value : string; }
    | Regular
      {
        Name : string;
        Type : option[ScriptType];
        Access : option[MemberAccess];
      }
  }
  
  public variant MemberAccess
  {
    | Public
    | Private
  }
  
  [Record]
  public class EnumMember
  {
    public Name : string { get; }
    public Value : option[int] { get; }
  }
}
