using Nemerle;
using Nemerle.Extensions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Peg;

using System;
using System.Collections.Generic;
using System.Linq;

namespace TSParser.Ast
{
  internal abstract class BaseEqualityComparer[T] :
    EqualityComparer[T] where T : class
  {
    public override GetHashCode(obj : T) : int
    {
      if(object.ReferenceEquals(obj, null)) 0 else InternalGetHashCode(obj)
    }
        
    public override Equals(l : T, r : T) : bool
    {
      if(object.ReferenceEquals(l, null) && object.ReferenceEquals(r, null))
        true
      else
      if(object.ReferenceEquals(l, null) || object.ReferenceEquals(r, null))
        false
      else
      if(!l.GetType().Equals(r.GetType()))
        false
      else
        InternalEquals(l, r)
    }
    
    public abstract InternalGetHashCode(obj : T) : int;
    public abstract InternalEquals(l : T, r : T) : bool;
  }
  
  internal class ScriptTypeEqualityComparer : BaseEqualityComparer[ScriptType]
  {
    public override InternalGetHashCode(obj : ScriptType) : int
    {
      | Any => 1
      | Number => 3
      | Boolean => 5
      | String => 7
      | Void => 9
      | Ref as r =>
        r.Name.GetHashCode() +
        r.TypeArguments.Sum(t => ScriptTypeEqualityComparer().GetHashCode(t))
      | Query as q => q.Name.GetHashCode()
      | Array as a => ScriptTypeEqualityComparer().GetHashCode(a.Type) + a.Rank
      | Object as o => 1001
      | Function as f => 2003
      | Constructor as c => 3007
    }
    
    public override InternalEquals(l : ScriptType, r : ScriptType) : bool
    {
      match(l)
      {
      | Any
      | Number
      | Boolean
      | String
      | Void => true      
      | _ =>
        match((l,r))
        {
        | (Ref as l, Ref as r) =>
          l.Name == r.Name &&
          Enumerable.SequenceEqual(l.TypeArguments, r.TypeArguments, ScriptTypeEqualityComparer())
        | (Query as l, Query as r)
        | (Array as l, Array as r)
        | (Object as l, Object as r)
        | (Function as l, Function as r)
        | (Constructor as l, Constructor as r) => true
        | _ => false
        }
      }
    }
  }
}