using System;
using System.Collections.Generic;
using System.Linq;

using Nemerle.Imperative;
using Nemerle.Macros;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using PT = Nemerle.Compiler.Parsetree;
using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.Assertions;
using System.IO;
using System.Text.RegularExpressions;
using TSParser;
using TSParser.Ast;
using NemerleWeb;

namespace NemerleWeb
{
  /// <summary>
  /// Description of TSGenerator.
  /// </summary>
  internal module TSGenerator
  {
    #region Public
    
    /// <summary>
    /// Create namespace and module 
    /// </summary>
    public GenerateCode(
      [NotNull] typer : Typer,
      [NotNull] root : string,
      [NotNull] tsAst : IEnumerable[DeclarationElement]) : void
    {
      def rootDot = root.SplitDot();
      
      def jsApiRoot = typer.Env.EnterIntoNamespace(rootDot);
      def jsApiRoot = jsApiRoot.Define(<[decl:module A{}]>);
      
      // First generate all types
      GenerateTypes(jsApiRoot, tsAst);
            
      // Generate types members
      GenerateTypesMembers(jsApiRoot, tsAst);
      
      // Then generate the rest: variables, functions.
      //GenerateRestMembers(jsApiRoot, tsAst);
      
      jsApiRoot.Compile();
    }
    
    #endregion
    
    #region Generate types
    
    private GenerateTypes(scope : TypeBuilder, members : IEnumerable[DeclarationElement]) : void
    {
      foreach(mem in members) 
      {
      | InterfaceDeclaration(value) => CreateInterface(scope, value, false)
      | AmbientDeclaration(value) => GenerateTypesAmbient(scope, value)
      | _ => ()
      }
    }
    
    private GenerateTypesAmbient(scope : TypeBuilder, ambient : AmbientDeclaration) : void
    {
      match(ambient)
      {
      | VariableDeclaration
      | FunctionDeclaration
      | ClassDeclaration         
      | EnumDeclaration          
      | ExternalModuleDeclaration => ()
      | ModuleDeclaration(value) => ()
      | _ => ()
      }
    }
    
    private GenerateTypesModule() : void
    {
    }
    
    #endregion
    
    #region Generate types members
    
    private GenerateTypesMembers(scope : TypeBuilder, members : IEnumerable[DeclarationElement]) : void
    {
      foreach(mem in members) 
      { 
      | InterfaceDeclaration(value) => CreateInterface(scope, value, true)
      | AmbientDeclaration(value) => GenerateTypesMembersAmbient(scope, value)
      | _ => ()
      }
    }
    
    private GenerateTypesMembersAmbient(scope : TypeBuilder, ambient : AmbientDeclaration) : void
    {
      match(ambient)
      {
      | VariableDeclaration(value) => ()//CreateVariable(scope, value)
      | FunctionDeclaration(value) => CreateFunction(scope, value)
      | ClassDeclaration         
      | EnumDeclaration          
      | ExternalModuleDeclaration => ()
      | ModuleDeclaration(value) => ()
      | _ => ()
      }
    }
    
    #endregion
    
    #region Code Generation
    
    private CreateInterface(
      scope : TypeBuilder,
      tsInterface : InterfaceDeclaration,
      generateMembers : bool) : void
    {
      def typeParameters = ConvertTypeParameters(tsInterface.TypeParameters);
        
      def extends = 
        if (generateMembers)
          tsInterface.Extends.Select(e => MakeFullType(scope, e, typeParameters));
        else
          [];
        
      def interfaceType = scope.DefineNestedType(
        <[ decl:
          [JSApi]
          public partial interface $(tsInterface.Name : usesite)[..$typeParameters] : ..$extends {}
        ]>);
      
      when (generateMembers)
        CreateObject(interfaceType, tsInterface.Type, tsInterface.Name);
        
      interfaceType.Compile();
    }

    private CreateVariable(scope : TypeBuilder, var : AmbientVariableDeclaration) : void
    {
      def typePrefix = string.Join(Separator, var.Name, Variable);
      def varType = ConvertType(scope, var.Type, typePrefix);
      
      _ = scope.Define(
        <[ decl: public new mutable $(var.Name : usesite) : $varType = default($varType); ]>);
    }
  
    private CreateFunction(scope : TypeBuilder, function : AmbientFunctionDeclaration) : void
    {
      CreateMethod(scope, function.Name, function.Signature, "");
    }
    
    CreateObject(scope : TypeBuilder, obj : ScriptType.Object, prefix : string) : void
    {
      foreach(mem in obj.Members) CreateObject(scope, mem, prefix);
    }
    
    CreateObject(scope : TypeBuilder, obj : ScriptObject, prefix : string) : void
    {
      match(obj)
      {
      | Call(value)      => CreateCall(scope, value, prefix)
      | Construct(value) => CreateConstruct(scope, value, prefix)
      | Index(value)     => CreateIndex(scope, value, prefix)
      | Property(value)  => CreateProperty(scope, value, prefix)
      | Method(value)    => CreateMethod(scope, value, prefix)
      | _ => ()
      }
    }
    
    CreateCall(scope : TypeBuilder, call : CallSignature, prefix : string) : void
    {
      def fullPrefix = string.Join(Separator, prefix, Call);
      def returnTypePrefix = string.Join(Separator, fullPrefix, Return);
      def realReturnType = ConvertType(scope, call.ReturnType, returnTypePrefix);
      
      def functionParams = ConvertParameters(scope, call.Parameters, fullPrefix);
      when(functionParams is None()) return;      
      def functionParams = functionParams.Value;
      
      def typeParameters = ConvertTypeParameters(call.TypeParameters);
      
      scope.DefineMemberPublicNew(
        <[ decl: $(JSApiSpecial.Call : usesite)[..$typeParameters](..$functionParams) : $realReturnType; ]>);
    }
   
    CreateConstruct(scope : TypeBuilder, construct : Construct, prefix : string) : void
    {
      def fullPrefix = string.Join(Separator, prefix, New);
      def returnTypePrefix = string.Join(Separator, fullPrefix, Return);
      def realReturnType = ConvertType(scope, construct.ReturnType, returnTypePrefix);
    
      def functionParams = ConvertParameters(scope, construct.Parameters, fullPrefix);
      when(functionParams is None()) return;      
      def functionParams = functionParams.Value;
      
      def typeParameters = ConvertTypeParameters(construct.TypeParameters);
      
      scope.DefineMemberPublicNew(
        <[ decl: $(JSApiSpecial.New : usesite)[..$typeParameters](..$functionParams) : $realReturnType; ]>);
    }
    
    CreateIndex(scope : TypeBuilder, index : IndexSignature , prefix : string) : void
    {
      def (realParamType, typeName) =
        match(index.ParameterType)
        {
        | Number => (<[ float ]>, "Number")
        | String => (<[ string ]>, "String")
        };
        
      def fullPrefix = string.Join(Separator, prefix, typeName, Index);
      def returnTypePrefix = string.Join(Separator, fullPrefix, Return);
      def realReturnType = ConvertType(scope, index.ReturnType, returnTypePrefix);
      
      scope.DefineMemberPublicNew(
        <[ decl:
          new Item[$(index.ParameterName : usesite) : $realParamType] : $realReturnType
          {
            get;
            set;
          }
        ]>);
    }

    /// <summary>
    /// Don't pay attention to optional, always generate property
    /// </summary>
    CreateProperty(scope : TypeBuilder, property : Property, prefix : string) : void
    {
      def fullPrefix = string.Join(Separator, prefix, property.Name);
      def typePrefix = string.Join(Separator, fullPrefix, Property);
      def propertyType = ConvertType(scope, property.Type, typePrefix);
      
      scope.DefineMemberPublicNew(
        <[ decl: $(property.Name : usesite) : $propertyType { get; set; }; ]>);
    }
    
    /// <summary>
    /// Don't pay attention to optional, always generate method
    /// </summary>
    CreateMethod(scope : TypeBuilder, method : Method, prefix : string) : void
    {
      CreateMethod(scope, method.Name, method.Signature, prefix);
    }
    
    CreateMethod(
      scope : TypeBuilder,
      name : string,
      signature : CallSignature,
      prefix : string) : void
    {
      def fullPrefix = string.Join(Separator, prefix, name);
      def returnTypePrefix = string.Join(Separator, fullPrefix, Return);
      def realReturnType = ConvertType(scope, signature.ReturnType, returnTypePrefix);
    
      def functionParams = ConvertParameters(scope, signature.Parameters, fullPrefix);
      when(functionParams is None()) return;      
      def functionParams = functionParams.Value;
      
      def typeParameters = ConvertTypeParameters(signature.TypeParameters);
    
      scope.DefineMemberPublicNew(
        <[ decl: $(name : usesite)[..$typeParameters](..$functionParams) : $realReturnType; ]>);
    }
    
    static mutable anonymousTypeIndex : int = 0;
    
    private CreateAnonymousType(
      scope : TypeBuilder,
      obj : ScriptType.Object,
      prefix : string) : PExpr
    {
      // Filter out pseudo types
      if(obj.Members is [])
        <[ object ]>
      else
      {
        anonymousTypeIndex++;
        
        def name = string.Join(Separator, prefix, AnonymousType, anonymousTypeIndex.ToString());
        
        def type = scope.DefineNestedType(
          <[ decl: 
            [JSApi] public sealed class $(name : usesite) { }
          ]>);
          
        // Suppress warning
        type.HasBeenUsed = true;
        
        CreateObject(type, obj, name);
        type.Compile();
          
        <[ $(name : usesite) ]>
      }
    }
    
    private CreateModule() : TypeBuilder
    {
      null
    }
    
    #endregion
    
    #region Converters
    
    /// <summary>
    /// Makes type with type argument
    /// </summary>
    private MakeFullType(
      scope : TypeBuilder,
      typeRef : ScriptType.Ref,
      typeParameters : IEnumerable[PT.Splicable]) : PExpr
    {
      def typeArguments = typeRef.TypeArguments.Select(
        tyArg => MakeFullTypeImpl(scope, tyArg, typeParameters));
      <[ $(typeRef.Name : usesite).[..$typeArguments] ]>
    }
    
    /// <summary>
    /// Get PExpr from TS type
    /// </summary>
    private MakeFullTypeImpl(
      scope : TypeBuilder,
      type : ScriptType,
      typeParameters : IEnumerable[PT.Splicable]) : PExpr
    {
      match(type)
      {
      | Any => <[ object ]>
      | Number => <[ float ]>
      | Boolean => <[ bool ]>
      | String => <[ string ]>
      | Void => <[ void ]>
      | Ref as r => MakeFullType(scope, r, typeParameters)
      | Query => Message.Warning("Query type argument unsupported"); <[ object ]>
      | Array => Message.Warning("Array type argument unsupported"); <[ object ]>
      | Object as o =>
        if(o.Members is [])
          <[ object ]>
        else
        {
          Message.Warning("Object type argument is supported only without members");
          <[ object ]>
        }        
      | Function => Message.Warning("Function type argument unsupported"); <[ object ]>
      | Constructor => Message.Warning("Constructor type argument unsupported"); <[ object ]>
      | _ => Message.Warning($"Unsupport type argument $type");  <[ object ]>
      }
    }
    
    private ConvertTypeParameters(typeParameters : IEnumerable[ScriptTypeParameter])
      : list[PT.Splicable]
    {
      typeParameters.Select(e => PT.Splicable.Name(<[ $(e.Name : dyn) ]>)).NToList()
    }
    
    private GetParameterPrefix(prefix : string, name : string) : string
    {
      string.Join(Separator, prefix, name, Parameter)
    }
    
    /// <summary>
    /// Convert function parameters
    /// If there is a literal parameter, None is returned.
    /// </summary>
    private ConvertParameters(
      scope : TypeBuilder,
      parms : IEnumerable[ScriptParameter],
      prefix : string) : option[List[PParameter]]
    {
      def convert(p : ScriptParameter) : option[PParameter]
      {
        // Literal parameters are not supported now
        | Required(RequiredParameter.Literal) => None()          
        | Required(RequiredParameter.Regular(name, type, _))
        | Optional(name, type, _, _) => 
          def realType = ConvertType(scope, type, GetParameterPrefix(prefix, name));
          Some(<[ parameter: $(name : usesite) : $realType ]>)
        | Rest(name, type) =>          
          def realType = ConvertType(scope, type, GetParameterPrefix(prefix, name));
          Some(<[ parameter: params $(name : usesite) : $realType ]>)
      }
      
      def ret = List();
      foreach(parm in parms)
      {
        def maybeRealParam = convert(parm);
        if(maybeRealParam is Some(realParam))
          ret.Add(realParam);
        else
          return None();
      }
      
      Some(ret);
    }
    
    /// <summary>
    /// Return parameters types
    /// </summary>
    private GetParametersType(
      scope : TypeBuilder, 
      parms : list[ScriptParameter],
      prefix : string) : list[PExpr]
    {
      def convertParamsType(p : ScriptParameter)
      {
        // Literal parameters are not supported now
        | Required(RequiredParameter.Literal) =>
          throw InvalidOperationException("Literal parameters are not supported")
        | Required(RequiredParameter.Regular(name, type, _))
        | Optional(name, type, _, _) => 
          ConvertType(scope, type, GetParameterPrefix(prefix, name))
        | Rest(name, type) =>
          ConvertType(scope, type, GetParameterPrefix(prefix, name))
      }
    
      def ret = parms.Map(convertParamsType);
      ret
    }
    
    private ConvertType(scope : TypeBuilder, type : option[ScriptType], prefix : string) : PExpr
    {
      if(type is Some(t)) ConvertType(scope, t, prefix) else <[ object ]>
    }
    
    private ConvertType(scope : TypeBuilder, type : ScriptType, prefix : string) : PExpr
    {
      match(type)
      {
      | Any => <[ object ]>
      | Array(t, 0) => <[ $(ConvertType(scope, t, prefix)) ]>
      | Array(t, rank) => <[ array[$(ConvertType(scope, ScriptType.Array(t, rank - 1), prefix))] ]>
      | Boolean => <[ bool ]>
      | Constructor => <[ object ]>
      | Function(value) =>
        // TODO: Handle generic function literals
        if(value.TypeParameters is [])
        {
          mutable lambdaParams = GetParametersType(scope, value.Parameters, prefix);
          def type =
            if(value.ReturnType is ScriptType.Void())
              <[ System.Action ]>
            else
            {
              lambdaParams = lambdaParams.Concat([ConvertType(scope, value.ReturnType, prefix)]);
              <[ System.Func ]>
            };
          
          <[ $type.[..$lambdaParams] ]>
        }
        else
        {
          <[object]>
        }
        
      | Number => <[ float ]>
      | Object as type => CreateAnonymousType(scope, type, prefix)
      | Query => assert2(false); <[ object ]>
      // TODO: Support local Array type
      | Ref("Array", tyArgs) =>
        def tyArg =
          match(tyArgs)
          {
          | [] => ScriptType.Any()
          | [tyArg] => tyArg
          | _ =>
            Message.Warning("Array cannot receive more than one type argument, using the first one." + 
              $" Type: $(scope.FullName)");
            tyArgs.Head
          };
          
        def typeArgumentPrefix = string.Join(Separator, prefix, TypeArgument);
        def realType = ConvertType(scope, tyArg, typeArgumentPrefix);
        
        <[ array[$realType] ]>
          
      | Ref(name, tyArgs) => 
        def typeArgumentPrefix = string.Join(Separator, prefix, TypeArgument);
        def realTypeArguments = tyArgs.Map(type => ConvertType(scope, type, typeArgumentPrefix));
      
        <[ $(name : usesite).[..$realTypeArguments] ]>
      | String => <[ string ]>
      | Void => <[ void ]>
      }
    }
    
    #endregion
    
    #region Special constants
    
    private Call = "Call";
    private New = "New";
    private Variable = "Variable";
    private Constructor = "Constructor";
    private Index = "Index";
    private Return = "Return";
    private Parameter = "Parameter";
    private AnonymousType = "AnonymousType";
    private TypeArgument = "TypeArgument";
    private Separator = "_";
    
    #endregion
    
    #region Helpers
    
    
    #endregion
  }
  
  internal module ScopeExtensions
  {
    public DefineMemberPublicNew(this scope : TypeBuilder, member : ClassMember) : void
    {
      when(!scope.IsInterface)
      {
        match(member)
        {
        | f is ClassMember.Function =>
          f.body = DefaultFunctionImplementation;
        | p is ClassMember.Property =>
          when(p.getter is Some(getter))
            getter.body = DefaultFunctionImplementation;
          when(p.setter is Some(setter))
            setter.body = DefaultFunctionImplementation;
        | _ => ()
        }
      }
      
      member.modifiers.mods |= NemerleModifiers.New;
      when(!scope.IsInterface)
        member.modifiers.mods |= NemerleModifiers.Public;
      
      _ = scope.DefineWithSource(member);
    }
    
    private DefaultImplementation : PExpr =
      <[ { IgnoreParams(); throw NemerleWeb.ClientCodeCalledInServerException(); } ]>;
    private DefaultFunctionImplementation : FunBody.Parsed =
      FunBody.Parsed(DefaultImplementation);
  }
}
