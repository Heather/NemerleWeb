using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Assertions;

using System;
using System.Security.Cryptography;
using System.Text;
using System.IO;
using System.Web;
using System.Globalization;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Runtime.InteropServices;
using BF = System.Reflection.BindingFlags;
using TExpr = Nemerle.Compiler.Typedtree.TExpr;

namespace NemerleWeb
{
  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
  public macro Unit(tb : TypeBuilder)
  {
    UnitImpl.DoTransformBeforeInheritance(tb, Macros.ImplicitCTX())
  }
  
  [MacroUsage(MacroPhase.BeforeTypedMembers, MacroTargets.Class)]
  public macro Unit(tb : TypeBuilder) 
  {
    UnitImpl.DoTransformBeforeTypedMembers(tb, Macros.ImplicitCTX())
  }
  
  [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Class)]
  public macro Unit(tb : TypeBuilder) 
  {
    UnitImpl.DoTransform(tb, Macros.ImplicitCTX())
  }
  
  module UnitImpl
  { 
    _scriptsDirectory = Path.Combine("Scripts", "nweb");
    
    public DoTransformBeforeInheritance(tb : TypeBuilder, typer : Typer) : void
    {
      Macros.DefineCTX(typer);
      
      unless(typer.Manager.IsIntelliSenseMode)
      {
        AddPageBaseMethods(tb, typer);
      
        def vmInterface = <[ ttype: NemerleWeb.IPage ]>;
        def superTypes = tb.GetDirectSuperTypes();
        
        unless (superTypes != null && superTypes.Exists(t => t.Equals(vmInterface)))
          tb.AddImplementedInterface(<[ NemerleWeb.IPage ]>);
      }
    }
     
    public DoTransformBeforeTypedMembers(tb : TypeBuilder, typer : Typer) : void
    {      
      Macros.DefineCTX(typer);
      
      JSClass.IEnumerableType = <[ ttype : System.Collections.IEnumerable ]>;
      JSClass.StringType = <[ ttype : System.String ]>;
      JSClass.IPageType = <[ ttype: IPage ]>;
      JSClass.ObjectType = <[ ttype: System.Object ]>;
        
      unless(typer.Manager.IsIntelliSenseMode)
      {
        // TODO: Add better check for WebSite project
        //when(tb.Manager.ReferencedAssemblies
        //  .Any(a => a.Assembly.FullName.Contains("System.Web.Razor")))
          CreateResourceController(tb, typer);
      }
            
      def translateMethod(typer) 
      {
        match(typer.CurrentFunction.body) 
        {
        | FunBody.Typed(body) =>
          def methodBuilder = typer.CurrentMethodBuilder;          
          def shouldReturn = !(methodBuilder.Header.ReturnType is FixedType.Void()) && !methodBuilder.IsConstructor;
          def ast = JSAstBuilder.BuildJSAst(body, shouldReturn, methodBuilder.Header);
          JSAstCache.AddMethodAst(typer.CurrentTypeBuilder, typer.CurrentFunction, ast);
        | _ => ()
        }
      }
            
      def processType(typeBuilder) 
      { 
        def getAncesterCount(t : TypeInfo) {
          if(t.DeclaringType != null) getAncesterCount(t.DeclaringType) + 1 else 0;
        }
        
        typeBuilder.MethodBeforeStage3 += (_, e) => translateMethod(e.Typer);        
        typeBuilder.DoBeforeFinalization(() => {
          def jsClass = JSClass(typeBuilder, "  ", typer);
          AddMainData(typeBuilder, jsClass.Write(), getAncesterCount(typeBuilder));
          AddStaticFields(typeBuilder, jsClass.GetStaticConstructorBody(""));
        });
      }
      
      def getAllNestedTypes(tb, isTopMost)
      {
        def children = JSClass.GetNestedTypes(tb)
                              .Map(t => getAllNestedTypes(t, false))
                              .Flatten();
                              
        if(isTopMost) children else tb :: children;
      }
      
      processType(tb);      
      
      foreach(nestedType in getAllNestedTypes(tb, true))
          processType(nestedType);
    }
    
    static mutable collectedJSApiRoots : bool = false;

    public DoTransform(tb : TypeBuilder, typer : Typer) : void
    {
      unless(typer.Manager.IsIntelliSenseMode)
        DoTransformImpl(tb, typer);
    }
    
    public DoTransformImpl(tb : TypeBuilder, typer : Typer) : void
    {
      Macros.DefineCTX(typer);
      
      def cacheFieldInitializers(typeBuilder) 
      {     
        foreach(fld in typeBuilder.GetFields().Cast.[FieldBuilder]())        
          JSAstCache.AddFieldInitializer(typeBuilder, fld.Name, fld?.Ast?.Initializer);        
      }
      
      cacheFieldInitializers(tb);
      JSClass.GetNestedTypes(tb).Iter(cacheFieldInitializers);
      
      // Do not collect JS roots twice
      when(!collectedJSApiRoots)
      {
        ValidateReferences(tb.Manager);
        
        CollectJSApiRoots(typer);
        collectedJSApiRoots = true;
      }
      
      def parms = match(tb.GetConstructors().FirstOrDefault()) {
      | null => []
      | x => x.GetParameters();
      };
      def pparms = parms.Map(p => p.AsParsed());
      def signature = JSAstHelper.MethodSignature(parms);
      def properName = JSClass.GetProperName(tb);
      def serverParams = parms.Select(p => <[ paramList.Add("nweb.utils.toTypedObject(" + NWebUtils.ToJson($(p.Name : usesite)) + ")") ]>);
      
      GetRenderer(tb).Define(<[ decl: public $(tb.Name : dyn)(..$pparms) : string {
        
          def scripts = NemerleWeb.NWebData.GetScripts();
          def templates = NemerleWeb.NWebData.GetTemplates();
          def resources = NemerleWeb.NWebData.GetNemerleWebScripts();
          
          def declarations = string.Join("\n", templates.Concat(scripts));
          def unitName = $(properName : string);
          def paramList = List();
          paramList.Add($signature);
          {..$(serverParams.NToList())}
          def callParms = string.Join(",", paramList);

$<#
<div id="nweb-start"></div>
$resources
$declarations
<script>
$$(function() {  
  nweb.go(new $unitName($callParms));
});
</script>
#>
      }]>);
      
      def serverClass = tb.DeclaredNestedTypes.FirstOrDefault(t => t.Name == "Server");
      def serverMethods = Dictionary();
      if(serverClass != null)
      {          
          def env = typer.Manager.CoreEnv;
          def env = env.EnterIntoNamespace(tb.NamespaceNode);
          def controllerName = tb.Name + "Controller";
          def field = <[ decl: _server : $(serverClass.Name : usesite) = $(serverClass.Name : usesite)() ]>;          
          def controller = env.Define(<[ decl: 
            public class $(controllerName : usesite) : System.Web.Mvc.Controller
            {}
          ]>);
          controller.Define(field);
                 
          def proxy = tb.DefineNestedType(<[ decl:
              class ServerProxy
              {}
          ]>);
          proxy.HasBeenUsed = true;
          tb.Define(<[ decl: new server : ServerProxy { get { ServerProxy() } } ]>);
          
          foreach(method is IMethod
            when !method.IsConstructor && method.DeclaringType.FullName == serverClass.FullName
            in serverClass.GetMembers())
          {
            def parameters = method.GetParameters().Map(p => <[ $(p.Name : usesite) : $(p.ty : typed) ]>);
            def fparms = parameters.Map(PParameter);
            def methodName = controller.ParsedName.NewName(method.Name);
                  
            when(method.ReturnType.TryRequire(<[ ttype: void ]>))
              Message.FatalError("Server methods cannot return void, please return something");

            def deserializedParams = method
              .GetParameters()
              .Map(p => <[ parsedModel[$(p.Name : string)].ToObject.[$(p.ty : typed)]() ]>);
              
            // Do not override methods where MVC attributes defined
            def isMvcAttributeDefined(verb)
            {
              method.IsCustomAttributeDefined($"System.Web.Mvc.Http$(verb)Attribute");
            }
            def mvcAttributes = ["Get", "Post", "Put", "Delete"];
            def hasMvcAttribute = mvcAttributes.Any(isMvcAttributeDefined);
              
            def controllerMethod =
              if(hasMvcAttribute)
              {
                def callParams = method.GetParameters().Map(p => <[ $(p.Name : usesite) ]>);
                
                def m = <[ decl:
                  public new $(method.Name : usesite) (..$fparms) : System.Web.Mvc.ActionResult
                  {
                    def result = _server.$(method.Name : dyn)(..$callParams);
                    
                    def settings = Newtonsoft.Json.JsonSerializerSettings();
                    settings.TypeNameHandling = Newtonsoft.Json.TypeNameHandling.Objects;
                                
                    Content(Newtonsoft.Json.JsonConvert.SerializeObject(result, settings));
                  }
                ]>;
                
                // Add all attributes back
                m.AddCustomAttribute(<[ System.Web.Mvc.ValidateInput(false) ]>);
                foreach(a in m.GetCustomAttributes())
                  m.AddCustomAttribute(a);
                
                m
              }
              else
                (<[ decl: 
                  [System.Web.Mvc.HttpPost, System.Web.Mvc.ValidateInput(false)]
                  public new $(methodName : name) (model : string) : System.Web.Mvc.ActionResult
                  {
                    when(model == null) throw ArgumentNullException("model");
                
                    def parsedModel = Newtonsoft.Json.Linq.JObject.Parse(model);
                    _ = parsedModel;
                
                    def result = _server.$(method.Name : dyn)(..$deserializedParams);
                  
                    def settings = Newtonsoft.Json.JsonSerializerSettings();
                    settings.TypeNameHandling = Newtonsoft.Json.TypeNameHandling.Objects;
                                
                    Content(Newtonsoft.Json.JsonConvert.SerializeObject(result, settings));
                  }
                ]>);
            _ = controller.DefineWithSource(controllerMethod);
                  
            if (serverMethods.ContainsKey(method.Name))
            {
              serverMethods[method.Name] += fparms;
            }
            else
              serverMethods.Add(method.Name, fparms);
                  
            //when(method.Name == "TestPrimitives")
            //assert2(false);
            def allParms = fparms.Append([<[ parameter: _callback : Action[$(method.ReturnType : typed)] ]>]);
                  
            proxy.Define(<[ decl:                   
              public new $(methodName : name) (..$(allParms)) : NemerleWeb.TypedJS.XMLHttpRequest
              {
                IgnoreParams();
                throw ClientCodeCalledInServerException();
              }
            ]>);
          }
          controller.Define(<[ decl:
              public new __SetSignalRConnectionId(id : string) : System.Web.Mvc.ActionResult
              {                
                HttpContext.Current.Session["SignalRConnectionId"] = id;
                Content("");
              }]>);
          proxy.Compile();
          controller.Compile();
      }
      else
      {
        def server = tb.DefineNestedType(<[ decl: public class Server {} ]>);
        server.HasBeenUsed = true;
        server.Compile();
      }      
    }

    private MscorlibGuid = "BED7F4EA-1A96-11d2-8F08-00A0C9A6186D";
    
    private ValidateReferences(manager : ManagerClass) : void
    {
      // Check if developer didn't forget to add ALL needed reference to the project
      // If we don't see mscorlib here, something wrong happened.
      when (!manager.ReferencedAssemblies.Any(
            a => a.Assembly.GetCustomAttributes(typeof(GuidAttribute), false)
              .Cast.[GuidAttribute]()
              .Any(at => at.Value == MscorlibGuid)))
      {
        Message.Error($<#"You have forgotten to add all needed assembly references.
Please add the following: ..$(manager.ReferencedAssemblies; "\n"; a => a.Assembly.FullName)#>);
      }
    }
    
    private CollectJSApiRoots(typer : Typer) : void
    {
      // Collect from current and referenced assemblies
      foreach(lib in typer.Env.Manager.ReferencedAssemblies)
      {
        def jsApiRoots = lib.Assembly
          .GetCustomAttributes(typeof(NemerleWeb.JSApiRootAttribute), false)
          .Cast.[NemerleWeb.JSApiRootAttribute]();        
          
        foreach(r in jsApiRoots)
          when(!string.IsNullOrEmpty(r.Root) && !string.IsNullOrWhiteSpace(r.Root))
            _ = JSClassSettings.JSApiRoots.Add(r.Root);
      }
    }
    
    SaveToFile(tb : TypeBuilder, data : string, filename : string) : string
    {
      def dir = Path.GetDirectoryName(tb.Manager.Options.ProjectPath);
      def bytes = Encoding.Unicode.GetBytes(data);
      using(sha = SHA1CryptoServiceProvider()) 
      {
        def hash = BitConverter.ToString(sha.ComputeHash(bytes)).Replace("-", "");
        def scriptsDir = Path.Combine(dir, "Scripts", "NemerleWeb");
        def relativeScriptPath = Path.Combine("Scripts", "NemerleWeb", filename + "_" + hash + ".js");
        
        when(!Directory.Exists(scriptsDir))
          _ = Directory.CreateDirectory(scriptsDir);
          
        def filename = Path.Combine(dir, relativeScriptPath);
        
        File.WriteAllText(filename, data);
        
        tb.Manager.Options.EmbeddedResources ::= filename;
        
        relativeScriptPath
      }
    }
    
    AppendToNWebDataConstructor(tb : TypeBuilder, expr : PExpr) : void    
    {      
      def ctor = GetNWebDataConstructor(tb);      
      ctor.Body = <[ 
        $(ctor.Body);
        $expr;
      ]>;
    }
    
    public AddMainData(tb : TypeBuilder, data : string, ancestorCount : int) : void
    {      
      def filename = SaveToFile(tb, data, JSClass.GetProperName(tb));
      AppendToNWebDataConstructor(tb, <[ AddScript($(filename : string), $ancestorCount); ]>);
    }
    
    public AddStaticFields(tb : TypeBuilder, fields : string) : void
    {
      AppendToNWebDataConstructor(tb, <[ AddFields($(fields : string)); ]>);
    }
        
    public AddSignalrData(tb : TypeBuilder, data : string) : void
    {
      def filename = SaveToFile(tb, data, JSClass.GetProperName(tb) + "_signalr");
      AppendToNWebDataConstructor(tb, <[ AddScript($(filename : string), 0); ]>);
    }
    
    public AddTemplateData(tb : TypeBuilder, templateName : string, templateContent : string) : void
    {
      def id = JSClass.GetProperName(tb) + templateName;
      def filename = SaveToFile(tb, templateContent, id);
      AppendToNWebDataConstructor(tb, <[ AddTemplate($(id : string), $(filename : string)); ]>);
    }
    
    GetStaticConstructor(tb : TypeBuilder) : MethodBuilder
    {
      def ctor = tb.GetConstructors(BindingFlags.NonPublic | BindingFlags.Static).FirstOrDefault();
      match(ctor) 
      {
      | null => tb.DefineAndReturn(<[ decl: static this() {} ]>) :> MethodBuilder;        
      | x => x :> MethodBuilder
      }
    }
        
    GetNWebDataConstructor(tb : TypeBuilder) : MethodBuilder
    {
      def assemblyName = Path.GetFileNameWithoutExtension(tb.Manager.Options.OutputFileName);
      def env = tb.Manager.CoreEnv.EnterIntoNamespace([assemblyName]);
      match(env.LookupType(["NWebDataPerAssembly"])) 
      {
      | Some(type) => 
        type.GetConstructors(BindingFlags.Public | BindingFlags.Instance).First() :> MethodBuilder
      | None => 
        def t = env.Define(<[ decl:
          public class NWebDataPerAssembly : NemerleWeb.NWebDataInstance
          {
            public this() {}
          }
        ]>);
        t.Compile();
        t.GetConstructors().First() :> MethodBuilder;
      }
    }
    
    GetRenderer(tb : TypeBuilder) : TypeBuilder
    {
      def assemblyName = Path.GetFileNameWithoutExtension(tb.Manager.Options.OutputFileName);
      def env = tb.Manager.CoreEnv.EnterIntoNamespace([assemblyName]);
      match(env.LookupType(["Render"])) 
      {
      | Some(type) => type :> TypeBuilder
      | None => 
        def t = env.Define(<[ decl:
          public module Render
          {
            this() {}
          }
        ]>);
        t.Compile();
        t
      }
    }
    
    CreateResourceController(_tb : TypeBuilder, typer : Typer) : void
    {
      def env = typer.Manager.CoreEnv;
      def controllerName = "NemerleWebResourceController";
      when (env.LookupType([controllerName]) is None())
      {
        env.Define(<[ decl: 
          public class $(controllerName : usesite) : System.Web.Mvc.Controller
          {
            public NemerleWebJs() : System.Web.Mvc.ActionResult
            {
              def scripts =
              [
                "NemerleWeb.Scripts.json2.js",
                "NemerleWeb.Scripts.jquery-1.10.1.js",
                "NemerleWeb.Scripts.jquery.signalR-1.1.2.js",
                "NemerleWeb.Scripts.linq.js",
                "NemerleWeb.Scripts.nweb.js"
              ];
              
              try
              {
                def sb = System.Text.StringBuilder();
                foreach(file in scripts)
                  using(stream = typeof(NemerleWeb.JSAst).Assembly.GetManifestResourceStream(file))
                    if(stream != null)
                      using(reader = System.IO.StreamReader(stream))
                        _ = sb.Append(reader.ReadToEnd());
                    else
                    {
                      def errorMessage = $"!!!ERROR!!! Cannot find $file!!!";
                      _ = sb.Append($"\r\n// $errorMessage\r\nconsole.error($errorMessage);\r\n");
                    }
                
                Content(sb.ToString(), "text/javascript");
              }
              catch
              {
              | e => Content(e.ToString(), "text/javascript");
              }
            }
          }
        ]>).Compile();  
      }      
    }
    
    public AddPageBaseMethods(tb : TypeBuilder, typer : Typer) : void
    {                
      Macros.DefineCTX(typer);
      def T = 
        if(tb.ParsedDeclaration.DeclaredTypeParametersCount == 0)
          <[ $(tb.ParsedName : name) ]>
        else 
        {
          def tparms = tb.ParsedDeclaration.DeclaredTypeParameters;
          def tparms = tparms.tyvars.Map(t => <[ $(tb.ParsedName.NewName(t.ToString()) : name) ]>);
          <[ $(tb.ParsedName : name).[..$tparms] ]>;
        }
      
      def pageBaseMethods =
        [
          <[decl: [NemerleWeb.IgnoreAttribute] public new GetTemplateName([NotNull] modelName : string, [NotNull] viewName : string) : string { IgnoreParams(); "" } ]>,
        ];
        
      // Define and suppress warnings about unused parameters
      foreach(pageMethod in pageBaseMethods)
      {
        tb.Define(pageMethod);
      }
    }
  }
}
