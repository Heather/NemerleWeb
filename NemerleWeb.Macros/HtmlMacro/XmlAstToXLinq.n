using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Extensions;
using TT = Nemerle.Compiler.Typedtree;
using TExpr = Nemerle.Compiler.Typedtree.TExpr;

using System.Collections;
using System.Collections.Generic;
using System.Xml.Linq;
using System.Linq;
using System.Text.RegularExpressions;
using System.Diagnostics;
using L = System.Xml.Linq;
using X = NemerleWeb;
using SCG = System.Collections.Generic;
using NColl = Nemerle.Collections.NCollectionsExtensions;

namespace NemerleWeb
{  
  class XmlAstToXLinq
  {
    [Record]
    public class SpliceNode
    {
      public SpliceId : option[string];
      public PExpression : option[PExpr];
      public Children : List[SpliceNode];
      
      public IsForeach : bool { get; set; }
    }
    
    _typer  : Typer;
    _parser : XmlQuotParser;
    _methodNames : list[string];
    _splice : SpliceNode = SpliceNode(None(), None(), List(), false);
    
    mutable _spliceCounter : int = 0;
    
    public this([NotNull] typer : Typer, [NotNull] parser : XmlQuotParser)
    {
      _typer  = typer;
      _parser = parser;
      _methodNames = typer.CurrentType.GetMethods().Map(m => m.Name);
    }
          
    public ToLocation([NotNull] node : PegLocated) : Location
    {
      _parser.ToLocation(node)
    }
    
    Parse(loc : Location, code : string) : PExpr
    {
      _typer.Manager.MacroColors.PushUseSiteColor();
      def pExpr = try     MainParser.ParseExpr(_typer.Env, code, loc, false)
                  finally _typer.Manager.MacroColors.PopColor();
      pExpr
    }
    
    SplicablePExprStr(value : X.Splicable) : PExpr
    {
      Util.locate(ToLocation(value),
        match (value)
        {
          | Splicable.Value(value)    => <[ $(value : string) ]>
          | Splicable.Expr(expr)      => Parse(ToLocation(value), expr)          
          | Splicable.ListExpr(_expr) => Message.FatalError(<#The "..$" not supportend in name context.#>);
          | Splicable.ControlExpr     => assert(false)
        })
    }
    
    public Transform([NotNull] xmlAsts : XmlAst.Seq) : (PExpr * SpliceNode)
    { 
      def res = Util.locate(ToLocation(xmlAsts), TransformImpl(xmlAsts, _splice));
      (<[ $(res : string) ]>, _splice);
    }
    
    public TransformImpl([NotNull] xmlAst : XmlAst, spliceNode : SpliceNode, depth = 0 : int) : string
    {              
        def transformImpl(ast) {
          def newNode = SpliceNode(None(), None(), List(), false);
          spliceNode.Children.Add(newNode);
          TransformImpl(ast, newNode, depth + 1);
        }
        def ident = string.Join("", Enumerable.Repeat("  ", depth));
        
        def generateSplice(spliceExpr : string, isForeach = false : bool) : string {
          _spliceCounter++;
          def spliceId = _spliceCounter.ToString();
          def node = SpliceNode(Some(spliceId), Some(Parse(ToLocation(xmlAst), spliceExpr)), List(), isForeach);
          spliceNode.Children.Add(node);
          spliceId
        }
        
        match (xmlAst) {
        | Attr(name, Splicable.Expr as value) => $"nw-$name='$(generateSplice(value.expr))'"
        | Attr(Splicable.Value(name), value)  => $"$name='$value'"
        | Text(Splicable.Value(value))        => ident + value
        | Tag(Splicable.Value(name), content) =>
          def isInsideTag(c) { c is XmlAst.AttrSplice || c is XmlAst.Attr }
          def attrs = content.Where(c => isInsideTag(c)).Map(c => TransformImpl(c, spliceNode));          
          def children = content.Where(c => !isInsideTag(c)).Map(c => transformImpl(c));
                                  
$<#
$ident<$name ..$(attrs; " ")>..$(children; "")
$ident</$name>#>
        | TagSplice(expr, false)                 => $"<nwsplice nw-splice='$(generateSplice(expr))' />"
        | TagSplice(expr, true)                  => $"<nwsplice nw-splice='$(generateSplice(expr))' />"
        | AttrSplice(s, SpliceType.Foreach)      => $"nw-repeat='$(generateSplice(s, true))'"
        | AttrSplice(s, SpliceType.When)         => $"nw-when='$(generateSplice(s))'"
        | AttrSplice(s, SpliceType.Unless)       => $"nw-unless='$(generateSplice(s))'"
        | Seq(items)                             => string.Join("", items.Map(i => transformImpl(i)));
        | _                                      => Message.FatalError(ToLocation(xmlAst), "Unrecognized syntax in Html"); ""
        }
    }
    
    CreateAttribute(name : string, val : string) : XmlAst
    {
      XmlAst.Attr(0, 0, Splicable.Value(0, 0, name), Splicable.Value(0, 0, val))
    }
  }
}
